use anyhow::Result;
use embedded_svc::mqtt::client::{
    Event,
    QoS,
};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::prelude::*,
    mqtt::client::{EspMqttClient, MqttClientConfiguration},
};
use log::{info, warn};
use rf_core::{
    context::Context,
    vm::round_vm::RoundVM,
    lang::execution::round,
    export::Export,
};
use rf_distributed::{
    mailbox::{Mailbox, AsStates},
    message::Message,
};
use rf_distributed_esp::mailbox::EspMailbox;
use rufi_gradient::gradient;
use std::{thread::sleep, time::Duration};
use esp_client::wifi::wifi;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> Result<()>{
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let _wifi = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    // Client configuration:
    let broker_url = if app_config.mqtt_user != "" {
        format!(
            "mqtt://{}:{}@{}",
            app_config.mqtt_user, app_config.mqtt_pass, app_config.mqtt_host
        )
    } else {
        format!("mqtt://{}", app_config.mqtt_host)
    };
    let mqtt_config = MqttClientConfiguration::default();
    let mut client = EspMqttClient::new(
        &broker_url,
        &mqtt_config,
        move |message_event| match message_event {
            Ok(Event::Received(msg)) => {
                info!("Received a message: {:?}", msg);
            },
            _ => warn!("Received from MQTT: {:?}", message_event),
        },
    )?;

    client.subscribe(&format!("hello-rufi/1/subscriptions"), QoS::AtLeastOnce)?;

    let mut mailbox = EspMailbox::new();

    let context = Context::new(1, Default::default(), Default::default(), Default::default());

    loop {
        let states = mailbox.messages().as_states();

        let context = Context::new(
            *context.self_id(),
            context.local_sensors().clone(),
            context.nbr_sensors().clone(),
            states,
        );
        info!("CONTEXT: {:?}", context);
        let mut vm = RoundVM::new(context);
        vm.new_export_stack();
        let (mut vm_, result) = round(vm, gradient);
        let self_export: Export = vm_.export_data().clone();
        info!("OUTPUT: {}\nEXPORT: {}\n", result, self_export);
        let msg = Message::new(
            *vm_.self_id(),
            self_export,
            std::time::SystemTime::now(),
        );
        let msg_ser = serde_json::to_string(&msg)?;
        client.publish(
            format!("hello-rufi/1/subscriptions").as_str(), 
            QoS::AtLeastOnce, 
            false, 
            msg_ser.as_bytes(),
        )?;
    }
}
